diff --git a/lib/librumpnet/Makefile b/lib/librumpnet/Makefile
index f7dc5ff..55a1b71 100644
--- a/lib/librumpnet/Makefile
+++ b/lib/librumpnet/Makefile
@@ -7,4 +7,6 @@ LIBDPLIBS+=     rump	${.CURDIR}/../librump
 
 WARNS=		3	# XXX: kernel isn't ready for -Wsign-compare
 
+RUMPCOMP_USER=
+
 .include "${RUMPTOP}/librump/rumpnet/Makefile.rumpnet"
diff --git a/lib/librumpnet/rumpcomp_user.c b/lib/librumpnet/rumpcomp_user.c
index d70f4bb..8bd24c4 100644
--- a/lib/librumpnet/rumpcomp_user.c
+++ b/lib/librumpnet/rumpcomp_user.c
@@ -28,7 +28,7 @@ int rumpcomp_librumpnet_hive_request_port(
 		return EINVAL;
 	}
 
-	DPRINTF(("Hive bind succeeded.\n"));
+	DPRINTF(("Hive bind succeeded, result: %d.\n", *p_bind_result));
 	return 0;
 }
 
diff --git a/lib/librumpnet/swarm_ipc.c b/lib/librumpnet/swarm_ipc.c
deleted file mode 100644
index 159427b..0000000
--- a/lib/librumpnet/swarm_ipc.c
+++ /dev/null
@@ -1,205 +0,0 @@
-#include "swarm_ipc.h"
-#include <stdbool.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <assert.h>
-#include <errno.h>
-
-struct unxsock_msg {
-    uint32_t um_ver;
-    int32_t um_msgid;
-};
-
-struct getshm_msg {
-    // nothing to send so far
-};
-
-struct getshm_rep {
-    in_addr_t gr_ip_address;
-    uint32_t gr_filename_len;
-    /*
-     * The protocol requires the sender to supply
-     * gr_filename_len bytes of data for the client
-     * following this structure (Version 1).
-     */
-};
-
-struct bind_msg {
-    uint32_t bm_protocol;
-    uint32_t bm_resource;
-};
-
-struct bind_rep {
-    int32_t br_result;
-};
-
-#define DEFINE_STRUCT_OPERATION(OP, CONST) \
-static bool OP##_struct(int fd, CONST void *structp, size_t structsize) { \
-    size_t bytes_to_process = structsize; \
-\
-    /* proceed bytewise (int8_t*) */ \
-    CONST int8_t *hdrp = structp; \
-    while (bytes_to_process > 0) { \
-        ssize_t this_run = OP(fd, hdrp, bytes_to_process); \
-        if (this_run <= 0) { \
-            if (errno == EAGAIN || errno == EINTR) { \
-                continue; \
-            } \
-            return false; \
-        } \
-\
-        bytes_to_process -= this_run; \
-        hdrp += this_run; \
-    } \
-    /* no negative values (overreads) */ \
-    assert(bytes_to_process == 0); \
-\
-    return true; \
-}
-
-DEFINE_STRUCT_OPERATION(read,);
-DEFINE_STRUCT_OPERATION(write, const);
-
-int32_t rcv_message_type(int sock) {
-    struct unxsock_msg rcvd_hdr;
-    if (!read_struct(sock, &rcvd_hdr, sizeof(rcvd_hdr)) ||
-            rcvd_hdr.um_ver > USOCK_VERSION) {
-        return -errno;
-    }
-    if (rcvd_hdr.um_msgid < 0) {
-        return -EINVAL;
-    }
-    return rcvd_hdr.um_msgid;
-}
-
-static int send_message_type(int sock, int32_t msgid) {
-    struct unxsock_msg send_hdr = {
-        .um_ver = USOCK_VERSION,
-        .um_msgid = msgid,
-    };
-    if (!write_struct(sock, &send_hdr, sizeof(send_hdr))) {
-        return -errno;
-    }
-    return 0;
-}
-
-int request_swarm_getshm(int sock) {
-    int res;
-    if ((res = send_message_type(sock, SWARM_GETSHM))) {
-        return res;
-    }
-
-    //NOTE: Enable as soon as there is something to send
-    //struct getshm_msg to_send;
-
-    return 0;
-}
-
-int reply_swarm_getshm(int sock, in_addr_t ip_addr, char *filename) {
-    int res;
-    if ((res = send_message_type(sock, SWARM_GETSHM_REPLY))) {
-        return res;
-    }
-
-    assert(sizeof(size_t) >= sizeof(uint32_t));
-
-    size_t retr_len = strlen(filename);
-    if (retr_len >= UINT32_MAX) {
-        return -EINVAL;
-    }
-    struct getshm_rep to_send = {
-        .gr_ip_address = ip_addr,
-        .gr_filename_len = (uint32_t) retr_len
-    };
-
-    if (!write_struct(sock, &to_send, sizeof(to_send))) {
-        return -errno;
-    }
-
-    if (!write_struct(sock, filename, to_send.gr_filename_len)) {
-        return -errno;
-    }
-    return 0;
-}
-
-int request_hive_bind(int sock, uint32_t protocol, uint32_t port) {
-    int res;
-    if ((res = send_message_type(sock, HIVE_BIND))) {
-        return res;
-    }
-
-    struct bind_msg to_send = {
-        .bm_protocol = protocol,
-        .bm_resource = port,
-    };
-    if (!write_struct(sock, &to_send, sizeof(to_send))) {
-        return -errno;
-    }
-    return 0;
-}
-
-int reply_hive_bind(int sock, int32_t result) {
-    int res;
-    if ((res = send_message_type(sock, HIVE_BIND_REPLY))) {
-        return res;
-    }
-
-    struct bind_rep to_send = {
-        .br_result = result,
-    };
-    if (!write_struct(sock, &to_send, sizeof(to_send))) {
-        return -errno;
-    }
-    return 0;
-}
-
-int rcv_request_swarm_getshm(int sock) {
-    /* fill in something as soon as required */
-    return 0;
-}
-
-int rcv_reply_swarm_getshm(int sock, in_addr_t *ip_addr, char **filename) {
-    struct getshm_rep to_rcv = {};
-    if (!read_struct(sock, &to_rcv, sizeof(to_rcv))) {
-        return -errno;
-    }
-
-    assert(sizeof(size_t) >= sizeof(uint32_t));
-    size_t rcvd_filename_size = to_rcv.gr_filename_len + 1;
-    char *rcvd_filename = malloc(rcvd_filename_size);
-    if (!rcvd_filename) {
-        // this error code means something like "computer on fire"
-        return -1;
-    }
-    memset(rcvd_filename, 0, rcvd_filename_size);
-
-    if (!read_struct(sock, rcvd_filename, to_rcv.gr_filename_len)) {
-        return -errno;
-    }
-
-    *ip_addr = to_rcv.gr_ip_address;
-    *filename = rcvd_filename;
-    return 0;
-}
-
-int rcv_request_hive_bind(int sock, uint32_t *protocol, uint32_t *port) {
-    struct bind_msg to_rcv = {};
-    if (!read_struct(sock, &to_rcv, sizeof(to_rcv))) {
-        return -errno;
-    }
-
-    *protocol = to_rcv.bm_protocol;
-    *port = to_rcv.bm_resource;
-    return 0;
-}
-
-int rcv_reply_hive_bind(int sock, int32_t *result) {
-    struct bind_rep to_rcv = {};
-    if (!read_struct(sock, &to_rcv, sizeof(to_rcv))) {
-        return -errno;
-    }
-
-    *result = to_rcv.br_result;
-    return 0;
-}
diff --git a/lib/librumpnet/swarm_ipc.c b/lib/librumpnet/swarm_ipc.c
new file mode 120000
index 0000000..b13d122
--- /dev/null
+++ b/lib/librumpnet/swarm_ipc.c
@@ -0,0 +1 @@
+../../../examples/swarm_ipc.c
\ No newline at end of file
diff --git a/lib/librumpnet/swarm_ipc.h b/lib/librumpnet/swarm_ipc.h
deleted file mode 100644
index 8a19c01..0000000
--- a/lib/librumpnet/swarm_ipc.h
+++ /dev/null
@@ -1,64 +0,0 @@
-#ifndef __SWARM_IPC_H__
-#define __SWARM_IPC_H__
-
-#include <inttypes.h>
-#include <arpa/inet.h>
-
-#define USOCK_VERSION 1
-
-#define SWARM_GETSHM 1
-#define SWARM_GETSHM_REPLY 3
-#define HIVE_BIND 2
-#define HIVE_BIND_REPLY 4
-
-#define PROTOCOL_TCP 0
-#define PROTOCOL_UDP 1
-
-#define HIVE_SUCCESS 0
-#define HIVE_FAILURE -1
-
-/**
- * Request a shared memory area for packet transfer.
- * \param sock the UNIX socket to send the request to
- * \returns 0 on success, a negative error code otherwise
- */
-int request_swarm_getshm(int sock);
-/**
- * Send back information on the shared memory setup to the requester.
- * \param sock the UNIX socket to send the reply to
- * \param ip_addr the current IP address of the Swarm system
- * \param filename the file name for access to the shared memory area
- * \returns 0 on success, a negative error code otherwise
- */
-int reply_swarm_getshm(int sock, in_addr_t ip_addr, char *filename);
-/**
- * Request a connection.
- * \param sock the UNIX socket to send the request to
- * \param protocol the protocol for which to reserve the port
- * \param port the resource (port) to reserve for that protocol
- * \returns 0 on success, a negative error code otherwise
- */
-int request_hive_bind(int sock, uint32_t protocol, uint32_t port);
-/**
- * Send back information on the requested connection.
- * \param sock the UNIX socket to send the reply to
- * \param result the return code, indicating success or failure
- *        to reserve the connection
- * \returns 0 on success, a negative error code otherwise
- */
-int reply_hive_bind(int sock, int32_t result);
-
-/**
- * Receives the message header from \c sock and returns the message type.
- * Always call this function before invoking
- * one of the other \c rcv_XYZ functions.
- * \returns the message type ID or a negative error code
- */
-int32_t rcv_message_type(int sock);
-int rcv_request_swarm_getshm(int sock);
-int rcv_reply_swarm_getshm(int sock, in_addr_t *ip_addr, char **filename);
-int rcv_request_hive_bind(int sock, uint32_t *protocol, uint32_t *port);
-int rcv_reply_hive_bind(int sock, int32_t *result);
-
-#endif //__SWARM_IPC_H__
-
diff --git a/lib/librumpnet/swarm_ipc.h b/lib/librumpnet/swarm_ipc.h
new file mode 120000
index 0000000..db8902c
--- /dev/null
+++ b/lib/librumpnet/swarm_ipc.h
@@ -0,0 +1 @@
+../../../examples/swarm_ipc.h
\ No newline at end of file
diff --git a/sys/netinet/in_pcb.c b/sys/netinet/in_pcb.c
index 2b9428a..1a01929 100644
--- a/sys/netinet/in_pcb.c
+++ b/sys/netinet/in_pcb.c
@@ -259,7 +259,7 @@ in_pcbsetport(struct sockaddr_in *sin, struct inpcb *inp, kauth_cred_t cred)
        /*
         * Use RFC6056 randomized port selection
         */
-	error = portalgo_randport(&lport, &inp->inp_head, cred);
+	error = portalgo_randport(&lport, &inp->inp_head, table, cred);
 	if (error)
 		return error;
 
@@ -314,7 +314,7 @@ in_pcbbind_port(struct inpcb *inp, struct sockaddr_in *sin, kauth_cred_t cred)
 		 */
 		if (so->so_options & SO_REUSEADDR)
 			reuseport = SO_REUSEADDR|SO_REUSEPORT;
-	} 
+	}
 
 	if (sin->sin_port == 0) {
 		error = in_pcbsetport(sin, inp, cred);
diff --git a/sys/netinet/in_proto.c b/sys/netinet/in_proto.c
index c8e2f7c..2909b21 100644
--- a/sys/netinet/in_proto.c
+++ b/sys/netinet/in_proto.c
@@ -315,7 +315,7 @@ const struct protosw inetsw[] = {
 	.pr_domain = &inetdomain,
 	.pr_protocol = IPPROTO_IGMP,
 	.pr_flags = PR_ATOMIC|PR_ADDR|PR_LASTHDR,
-	.pr_input = igmp_input, 
+	.pr_input = igmp_input,
 	.pr_output = rip_output,
 	.pr_ctloutput = rip_ctloutput,
 	.pr_ctlinput = rip_ctlinput,
@@ -329,7 +329,7 @@ const struct protosw inetsw[] = {
 	.pr_domain = &inetdomain,
 	.pr_protocol = IPPROTO_PIM,
 	.pr_flags = PR_ATOMIC|PR_ADDR|PR_LASTHDR,
-	.pr_input = pim_input, 
+	.pr_input = pim_input,
 	.pr_output = rip_output,
 	.pr_ctloutput = rip_ctloutput,
 	.pr_ctlinput = rip_ctlinput,
@@ -340,7 +340,7 @@ const struct protosw inetsw[] = {
 {	.pr_type = SOCK_RAW,
 	.pr_domain = &inetdomain,
 	.pr_flags = PR_ATOMIC|PR_ADDR|PR_LASTHDR,
-	.pr_input = rip_input, 
+	.pr_input = rip_input,
 	.pr_output = rip_output,
 	.pr_ctloutput = rip_ctloutput,
 	.pr_ctlinput = rip_ctlinput,
@@ -388,6 +388,8 @@ u_char	ip_protox[IPPROTO_MAX];
 
 int icmperrppslim = 100;			/* 100pps */
 
+int netbsd_kernel_protocol = -1;
+
 static void
 sockaddr_in_addrlen(const struct sockaddr *sa, socklen_t *slenp)
 {
diff --git a/sys/netinet/portalgo.c b/sys/netinet/portalgo.c
index ee44d02..259b64c 100644
--- a/sys/netinet/portalgo.c
+++ b/sys/netinet/portalgo.c
@@ -66,6 +66,7 @@ __KERNEL_RCSID(0, "$NetBSD: portalgo.c,v 1.5 2013/06/01 11:01:48 pooka Exp $");
 #include <netinet/tcp_vtw.h>
 
 #include "portalgo.h"
+#include "rumpcomp_user.h"
 
 #define NPROTO 2
 #define PORTALGO_TCP 0
@@ -145,6 +146,7 @@ static const portalgo_algorithm_t algos[] = {
 #define NALGOS __arraycount(algos)
 
 static uint16_t portalgo_next_ephemeral[NPROTO][NAF][NRANGES][NALGOS];
+extern int netbsd_kernel_protocol;
 
 /*
  * Access the pcb and copy the values of the last port and the ends of
@@ -756,9 +758,13 @@ algo_randinc(int algo, uint16_t *port, struct inpcb_hdr *inp_hdr,
 	return EINVAL;
 }
 
+#define	INPCBHASH_PORT(table, lport) \
+	&(table)->inpt_porthashtbl[ntohs(lport) & (table)->inpt_porthash]
+
 /* The generic function called in order to pick a port. */
 int
-portalgo_randport(uint16_t *port, struct inpcb_hdr *inp_hdr, kauth_cred_t cred)
+portalgo_randport(uint16_t *port, struct inpcb_hdr *inp_hdr,
+		struct	  inpcbtable *table, kauth_cred_t cred)
 {
 	int algo, error;
 	uint16_t lport;
@@ -821,17 +827,35 @@ portalgo_randport(uint16_t *port, struct inpcb_hdr *inp_hdr, kauth_cred_t cred)
 
 	DPRINTF("%s portalgo = %d\n", __func__, algo);
 
-	error = (*algos[algo].func)(algo, &lport, inp_hdr, cred);
-	if (error == 0) {
-		*port = lport;
-	} else if (error != EAGAIN) {
-		uint16_t lastport, mymin, mymax, *pnext_ephemeral;
-
-		error = pcb_getports(inp_hdr, &lastport, &mymin,
-		    &mymax, &pnext_ephemeral, algo);
-		if (error)
-			return error;
-		*port = lastport - 1;
+	int32_t hive_result = -1;
+	error = 0;
+	while (!error && hive_result) {
+		error = (*algos[algo].func)(algo, &lport, inp_hdr, cred);
+		if (error == 0) {
+			error = rumpcomp_librumpnet_hive_request_port(
+                        lport, &hive_result, netbsd_kernel_protocol);
+			if (error)
+				return error;
+			if (hive_result) {
+				// insert dummy entry for future lookups
+				LIST_REMOVE(inp_hdr, inph_lhash);
+				LIST_INSERT_HEAD(
+						INPCBHASH_PORT(table, lport),
+						inp_hdr,
+						inph_lhash);
+				continue;
+			}
+			*port = lport;
+		} else if (error != EAGAIN) {
+			uint16_t lastport, mymin, mymax, *pnext_ephemeral;
+
+			error = pcb_getports(inp_hdr, &lastport, &mymin,
+					&mymax, &pnext_ephemeral, algo);
+			if (error)
+				return error;
+			*port = lastport - 1;
+			break;
+		}
 	}
 	return error;
 }
diff --git a/sys/netinet/portalgo.h b/sys/netinet/portalgo.h
index 634ca72..2692035 100644
--- a/sys/netinet/portalgo.h
+++ b/sys/netinet/portalgo.h
@@ -32,9 +32,11 @@
 
 #ifdef _KERNEL
 #include <sys/sysctl.h>
+#include <netinet/in_pcb_hdr.h>
 
 struct inpcb_hdr;
-int portalgo_randport(uint16_t *, struct inpcb_hdr *, kauth_cred_t);
+int portalgo_randport(uint16_t *, struct inpcb_hdr *,
+          struct	  inpcbtable *table, kauth_cred_t);
 int sysctl_portalgo_selected4(SYSCTLFN_ARGS);
 int sysctl_portalgo_selected6(SYSCTLFN_ARGS);
 int sysctl_portalgo_reserve4(SYSCTLFN_ARGS);
diff --git a/sys/netinet/rumpcomp_user.h b/sys/netinet/rumpcomp_user.h
deleted file mode 100644
index 2fa5e65..0000000
--- a/sys/netinet/rumpcomp_user.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifndef __NETINET_RUMPCOMP_USER__
-#define __NETINET_RUMPCOMP_USER__
-
-int hive_request_port(uint16_t port);
-
-#endif
diff --git a/sys/netinet/rumpcomp_user.h b/sys/netinet/rumpcomp_user.h
new file mode 120000
index 0000000..aa58526
--- /dev/null
+++ b/sys/netinet/rumpcomp_user.h
@@ -0,0 +1 @@
+../../lib/librumpnet/rumpcomp_user.h
\ No newline at end of file
diff --git a/sys/netinet/tcp_usrreq.c b/sys/netinet/tcp_usrreq.c
index cd23269..e041439 100644
--- a/sys/netinet/tcp_usrreq.c
+++ b/sys/netinet/tcp_usrreq.c
@@ -157,6 +157,8 @@ __KERNEL_RCSID(0, "$NetBSD: tcp_usrreq.c,v 1.170 2013/12/02 09:39:54 kefren Exp
  * TCP protocol interface to socket abstraction.
  */
 
+extern int netbsd_kernel_protocol;
+
 /*
  * Process a TCP user request for TCP tb.  If this is a send request
  * then m is the mbuf chain of send data.  If this is a timer expiration
@@ -178,6 +180,7 @@ tcp_usrreq(struct socket *so, int req,
 	int ostate = 0;
 #endif
 	int family;	/* family of the socket */
+	netbsd_kernel_protocol = 0;
 
 	family = so->so_proto->pr_domain->dom_family;
 
@@ -622,7 +625,7 @@ change_keepalive(struct socket *so, struct tcpcb *tp)
 	if (tp->t_state == TCPS_SYN_RECEIVED ||
 	    tp->t_state == TCPS_SYN_SENT) {
 		TCP_TIMER_ARM(tp, TCPT_KEEP, tp->t_keepinit);
-	} else if (so->so_options & SO_KEEPALIVE && 
+	} else if (so->so_options & SO_KEEPALIVE &&
 	    tp->t_state <= TCPS_CLOSE_WAIT) {
 		TCP_TIMER_ARM(tp, TCPT_KEEP, tp->t_keepintvl);
 	} else {
@@ -1224,14 +1227,14 @@ inet4_ident_core(struct in_addr raddr, u_int rport,
 	struct socket *sockp;
 
 	inp = in_pcblookup_connect(&tcbtable, raddr, rport, laddr, lport, 0);
-	
+
 	if (inp == NULL || (sockp = inp->inp_socket) == NULL)
 		return ESRCH;
 
 	if (dodrop) {
 		struct tcpcb *tp;
 		int error;
-		
+
 		if (inp == NULL || (tp = intotcpcb(inp)) == NULL ||
 		    (inp->inp_socket->so_options & SO_ACCEPTCONN) != 0)
 			return ESRCH;
@@ -1240,7 +1243,7 @@ inet4_ident_core(struct in_addr raddr, u_int rport,
 		    KAUTH_REQ_NETWORK_SOCKET_DROP, inp->inp_socket, tp, NULL);
 		if (error)
 			return (error);
-		
+
 		(void)tcp_drop(tp, ECONNABORTED);
 		return 0;
 	}
@@ -1262,11 +1265,11 @@ inet6_ident_core(struct in6_addr *raddr, u_int rport,
 
 	if (in6p == NULL || (sockp = in6p->in6p_socket) == NULL)
 		return ESRCH;
-	
+
 	if (dodrop) {
 		struct tcpcb *tp;
 		int error;
-		
+
 		if (in6p == NULL || (tp = in6totcpcb(in6p)) == NULL ||
 		    (in6p->in6p_socket->so_options & SO_ACCEPTCONN) != 0)
 			return ESRCH;
@@ -1335,7 +1338,7 @@ sysctl_net_inet_tcp_ident(SYSCTLFN_ARGS)
 		rport = (u_int)name[1];
 		laddr.s_addr = (uint32_t)name[2];
 		lport = (u_int)name[3];
-		
+
 		mutex_enter(softnet_lock);
 		error = inet4_ident_core(raddr, rport, laddr, lport,
 		    oldp, oldlenp, l, dodrop);
@@ -1399,7 +1402,7 @@ sysctl_net_inet_tcp_ident(SYSCTLFN_ARGS)
 		if (si4[0]->sin_len != sizeof(*si4[0]) ||
 		    si4[0]->sin_len != sizeof(*si4[1]))
 			return EINVAL;
-	
+
 		mutex_enter(softnet_lock);
 		error = inet4_ident_core(si4[0]->sin_addr, si4[0]->sin_port,
 		    si4[1]->sin_addr, si4[1]->sin_port,
@@ -1608,14 +1611,14 @@ sysctl_tcp_congctl(SYSCTLFN_ARGS)
 	char newname[TCPCC_MAXLEN];
 
 	strlcpy(newname, tcp_congctl_global_name, sizeof(newname) - 1);
-	
+
 	node = *rnode;
 	node.sysctl_data = newname;
 	node.sysctl_size = sizeof(newname);
 
 	error = sysctl_lookup(SYSCTLFN_CALL(&node));
-	
-	if (error || 
+
+	if (error ||
 	    newp == NULL ||
 	    strncmp(newname, tcp_congctl_global_name, sizeof(newname)) == 0)
 		return error;
@@ -1650,7 +1653,7 @@ sysctl_tcp_init_win(SYSCTLFN_ARGS)
 
 static int
 sysctl_tcp_keep(SYSCTLFN_ARGS)
-{  
+{
 	int error;
 	u_int tmp;
 	struct sysctlnode node;
@@ -2002,7 +2005,7 @@ sysctl_net_inet_tcp_setup2(struct sysctllog **clog, int pf, const char *pfname,
 		       SYSCTL_DESCR("Number of times to retry ECN setup "
 			       "before disabling ECN on the connection"),
 	    	       NULL, 0, &tcp_ecn_maxretries, 0, CTL_CREATE, CTL_EOL);
-	
+
 	/* SACK gets it's own little subtree. */
 	sysctl_createv(clog, 0, NULL, &sack_node,
 		       CTLFLAG_PERMANENT|CTLFLAG_READWRITE,
@@ -2122,7 +2125,7 @@ sysctl_net_inet_tcp_setup2(struct sysctllog **clog, int pf, const char *pfname,
 	sysctl_createv(clog, 0, &mslt_node, NULL,
 		       CTLFLAG_PERMANENT|CTLFLAG_READWRITE,
 		       CTLTYPE_INT, "remote_threshold",
-		       SYSCTL_DESCR("RTT estimate value to promote local to remote"), 
+		       SYSCTL_DESCR("RTT estimate value to promote local to remote"),
 		       NULL, 0, &tcp_msl_remote_threshold, 0, CTL_CREATE, CTL_EOL);
 
 	/* vestigial TIME_WAIT tuning subtree */
diff --git a/sys/netinet/udp_usrreq.c b/sys/netinet/udp_usrreq.c
index 27c7d07..8b53e30 100644
--- a/sys/netinet/udp_usrreq.c
+++ b/sys/netinet/udp_usrreq.c
@@ -144,6 +144,8 @@ __KERNEL_RCSID(0, "$NetBSD: udp_usrreq.c,v 1.193 2014/01/04 14:18:12 pooka Exp $
 int	udpcksum = 1;
 int	udp_do_loopback_cksum = 0;
 
+extern int netbsd_kernel_protocol;
+
 struct	inpcbtable udbtable;
 
 percpu_t *udpstat_percpu;
@@ -842,8 +844,8 @@ udp4_realinput(struct sockaddr_in *src, struct sockaddr_in *dst,
 
 			case 0: 	/* plain UDP */
 			default: 	/* Unexpected */
-				/* 
-				 * Normal UDP processing will take place 
+				/*
+				 * Normal UDP processing will take place
 				 * m may have changed.
 				 */
 				m = *mp;
@@ -1096,7 +1098,7 @@ udp_ctloutput(int op, struct socket *so, struct sockopt *sopt)
 				break;
 			}
 			break;
-		
+
 		default:
 			error = ENOPROTOOPT;
 			break;
@@ -1204,6 +1206,8 @@ udp_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam,
 	int s;
 	int error = 0;
 
+	netbsd_kernel_protocol = 1;
+
 	if (req == PRU_CONTROL)
 		return (in_control(so, (long)m, (void *)nam,
 		    (struct ifnet *)control, l));
@@ -1530,7 +1534,7 @@ udp4_espinudp(struct mbuf **mp, int off, struct sockaddr *src,
 	}
 
 	/*
-	 * Get the UDP ports. They are handled in network 
+	 * Get the UDP ports. They are handled in network
 	 * order everywhere in IPSEC_NAT_T code.
 	 */
 	udphdr = (struct udphdr *)((char *)data - skip);
@@ -1562,12 +1566,12 @@ udp4_espinudp(struct mbuf **mp, int off, struct sockaddr *src,
 
 	/*
 	 * We have modified the packet - it is now ESP, so we should not
-	 * return to UDP processing ... 
+	 * return to UDP processing ...
 	 *
 	 * Add a PACKET_TAG_IPSEC_NAT_T_PORT tag to remember
 	 * the source UDP port. This is required if we want
-	 * to select the right SPD for multiple hosts behind 
-	 * same NAT 
+	 * to select the right SPD for multiple hosts behind
+	 * same NAT
 	 */
 	if ((tag = m_tag_get(PACKET_TAG_IPSEC_NAT_T_PORTS,
 	    sizeof(sport) + sizeof(dport), M_DONTWAIT)) == NULL) {
diff --git a/sys/netinet6/in6_src.c b/sys/netinet6/in6_src.c
index a36fbb9..3c704bd 100644
--- a/sys/netinet6/in6_src.c
+++ b/sys/netinet6/in6_src.c
@@ -172,8 +172,8 @@ static struct in6_addrpolicy *match_addrsel_policy(struct sockaddr_in6 *);
 #endif
 
 struct in6_addr *
-in6_selectsrc(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts, 
-	struct ip6_moptions *mopts, struct route *ro, struct in6_addr *laddr, 
+in6_selectsrc(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
+	struct ip6_moptions *mopts, struct route *ro, struct in6_addr *laddr,
 	struct ifnet **ifpp, int *errorp)
 {
 	struct in6_addr dst;
@@ -426,7 +426,7 @@ in6_selectsrc(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
 				/* XXX breaks stat */
 				REPLACE(0);
 			}
-		}			
+		}
 	skip_rule4:
 #endif /* MIP6 && NMIP > 0 */
 
@@ -562,8 +562,8 @@ in6_selectsrc(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
 #undef NEXT
 
 static int
-selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts, 
-	struct ip6_moptions *mopts, struct route *ro, struct ifnet **retifp, 
+selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
+	struct ip6_moptions *mopts, struct route *ro, struct ifnet **retifp,
 	struct rtentry **retrt, int clone, int norouteok)
 {
 	int error = 0;
@@ -718,7 +718,7 @@ selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
 }
 
 static int
-in6_selectif(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts, 
+in6_selectif(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
 	struct ip6_moptions *mopts, struct route *ro, struct ifnet **retifp)
 {
 	int error, clone;
@@ -768,8 +768,8 @@ in6_selectif(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
  */
 
 int
-in6_selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts, 
-	struct ip6_moptions *mopts, struct route *ro, struct ifnet **retifp, 
+in6_selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
+	struct ip6_moptions *mopts, struct route *ro, struct ifnet **retifp,
 	struct rtentry **retrt, int clone)
 {
 	return selectroute(dstsock, opts, mopts, ro, retifp,
@@ -805,7 +805,7 @@ in6_pcbsetport(struct sockaddr_in6 *sin6, struct in6pcb *in6p, struct lwp *l)
 	u_int16_t lport, *lastport;
 	enum kauth_network_req req;
 	int error = 0;
-	
+
 	if (in6p->in6p_flags & IN6P_LOWPORT) {
 #ifndef IPNOPRIVPORTS
 		req = KAUTH_REQ_NETWORK_BIND_PRIVPORT;
@@ -828,10 +828,10 @@ in6_pcbsetport(struct sockaddr_in6 *sin6, struct in6pcb *in6p, struct lwp *l)
        /*
         * Use RFC6056 randomized port selection
         */
-	error = portalgo_randport(&lport, &in6p->in6p_head, l->l_cred);
+	error = portalgo_randport(&lport, &in6p->in6p_head, table, l->l_cred);
 	if (error)
 		return error;
-	
+
 	in6p->in6p_flags |= IN6P_ANONPORT;
 	*lastport = lport;
 	in6p->in6p_lport = htons(lport);

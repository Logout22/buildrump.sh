diff --git a/lib/librumpnet/Makefile b/lib/librumpnet/Makefile
index f7dc5ff..55a1b71 100644
--- a/lib/librumpnet/Makefile
+++ b/lib/librumpnet/Makefile
@@ -7,4 +7,6 @@ LIBDPLIBS+=     rump	${.CURDIR}/../librump
 
 WARNS=		3	# XXX: kernel isn't ready for -Wsign-compare
 
+RUMPCOMP_USER=
+
 .include "${RUMPTOP}/librump/rumpnet/Makefile.rumpnet"
diff --git a/lib/librumpnet/rumpcomp_user.c b/lib/librumpnet/rumpcomp_user.c
index d70f4bb..f18ac84 100644
--- a/lib/librumpnet/rumpcomp_user.c
+++ b/lib/librumpnet/rumpcomp_user.c
@@ -2,9 +2,7 @@
 #include <stdio.h>
 
 #include "rumpcomp_user.h"
-#include "swarm_ipc.c"
-
-extern int unix_socket;
+#include "swarm_client_ipc.c"
 
 #define DPRINTF(x) printf x
 
@@ -12,23 +10,24 @@ int rumpcomp_librumpnet_hive_request_port(
         uint16_t port, int32_t *p_bind_result,
         int netbsd_kernel_protocol) {
 	int err;
-	if ((err = request_hive_bind(unix_socket, netbsd_kernel_protocol, port))) {
+    DPRINTF(("NetBSD kernel protocol is %d\n", netbsd_kernel_protocol));
+	if ((err = request_hive_bind(netbsd_kernel_protocol, port))) {
 		DPRINTF(("Failed to send bind request: %d\n", err));
 		return EINVAL;
 	}
 
 	uint32_t ret_msg;
-	if ((ret_msg = rcv_message_type(unix_socket)) != HIVE_BIND_REPLY) {
+	if ((ret_msg = rcv_message_type_sock()) != HIVE_BIND_REPLY) {
 		DPRINTF(("Received wrong message header from Hive: %d\n", ret_msg));
 		return EINVAL;
 	}
 
-	if ((err = rcv_reply_hive_bind(unix_socket, p_bind_result))) {
+	if ((err = rcv_reply_hive_bind(p_bind_result))) {
 		DPRINTF(("Failed to receive bind result: %d\n", err));
 		return EINVAL;
 	}
 
-	DPRINTF(("Hive bind succeeded.\n"));
+	DPRINTF(("Hive bind succeeded, result: %d.\n", *p_bind_result));
 	return 0;
 }
 
diff --git a/sys/netinet/in_pcb.c b/sys/netinet/in_pcb.c
index 2b9428a..1a01929 100644
--- a/sys/netinet/in_pcb.c
+++ b/sys/netinet/in_pcb.c
@@ -259,7 +259,7 @@ in_pcbsetport(struct sockaddr_in *sin, struct inpcb *inp, kauth_cred_t cred)
        /*
         * Use RFC6056 randomized port selection
         */
-	error = portalgo_randport(&lport, &inp->inp_head, cred);
+	error = portalgo_randport(&lport, &inp->inp_head, table, cred);
 	if (error)
 		return error;
 
@@ -314,7 +314,7 @@ in_pcbbind_port(struct inpcb *inp, struct sockaddr_in *sin, kauth_cred_t cred)
 		 */
 		if (so->so_options & SO_REUSEADDR)
 			reuseport = SO_REUSEADDR|SO_REUSEPORT;
-	} 
+	}
 
 	if (sin->sin_port == 0) {
 		error = in_pcbsetport(sin, inp, cred);
diff --git a/sys/netinet/in_proto.c b/sys/netinet/in_proto.c
index c8e2f7c..2909b21 100644
--- a/sys/netinet/in_proto.c
+++ b/sys/netinet/in_proto.c
@@ -315,7 +315,7 @@ const struct protosw inetsw[] = {
 	.pr_domain = &inetdomain,
 	.pr_protocol = IPPROTO_IGMP,
 	.pr_flags = PR_ATOMIC|PR_ADDR|PR_LASTHDR,
-	.pr_input = igmp_input, 
+	.pr_input = igmp_input,
 	.pr_output = rip_output,
 	.pr_ctloutput = rip_ctloutput,
 	.pr_ctlinput = rip_ctlinput,
@@ -329,7 +329,7 @@ const struct protosw inetsw[] = {
 	.pr_domain = &inetdomain,
 	.pr_protocol = IPPROTO_PIM,
 	.pr_flags = PR_ATOMIC|PR_ADDR|PR_LASTHDR,
-	.pr_input = pim_input, 
+	.pr_input = pim_input,
 	.pr_output = rip_output,
 	.pr_ctloutput = rip_ctloutput,
 	.pr_ctlinput = rip_ctlinput,
@@ -340,7 +340,7 @@ const struct protosw inetsw[] = {
 {	.pr_type = SOCK_RAW,
 	.pr_domain = &inetdomain,
 	.pr_flags = PR_ATOMIC|PR_ADDR|PR_LASTHDR,
-	.pr_input = rip_input, 
+	.pr_input = rip_input,
 	.pr_output = rip_output,
 	.pr_ctloutput = rip_ctloutput,
 	.pr_ctlinput = rip_ctlinput,
@@ -388,6 +388,8 @@ u_char	ip_protox[IPPROTO_MAX];
 
 int icmperrppslim = 100;			/* 100pps */
 
+int netbsd_kernel_protocol = -1;
+
 static void
 sockaddr_in_addrlen(const struct sockaddr *sa, socklen_t *slenp)
 {
diff --git a/sys/netinet/portalgo.c b/sys/netinet/portalgo.c
index ee44d02..259b64c 100644
--- a/sys/netinet/portalgo.c
+++ b/sys/netinet/portalgo.c
@@ -66,6 +66,7 @@ __KERNEL_RCSID(0, "$NetBSD: portalgo.c,v 1.5 2013/06/01 11:01:48 pooka Exp $");
 #include <netinet/tcp_vtw.h>
 
 #include "portalgo.h"
+#include "rumpcomp_user.h"
 
 #define NPROTO 2
 #define PORTALGO_TCP 0
@@ -145,6 +146,7 @@ static const portalgo_algorithm_t algos[] = {
 #define NALGOS __arraycount(algos)
 
 static uint16_t portalgo_next_ephemeral[NPROTO][NAF][NRANGES][NALGOS];
+extern int netbsd_kernel_protocol;
 
 /*
  * Access the pcb and copy the values of the last port and the ends of
@@ -756,9 +758,13 @@ algo_randinc(int algo, uint16_t *port, struct inpcb_hdr *inp_hdr,
 	return EINVAL;
 }
 
+#define	INPCBHASH_PORT(table, lport) \
+	&(table)->inpt_porthashtbl[ntohs(lport) & (table)->inpt_porthash]
+
 /* The generic function called in order to pick a port. */
 int
-portalgo_randport(uint16_t *port, struct inpcb_hdr *inp_hdr, kauth_cred_t cred)
+portalgo_randport(uint16_t *port, struct inpcb_hdr *inp_hdr,
+		struct	  inpcbtable *table, kauth_cred_t cred)
 {
 	int algo, error;
 	uint16_t lport;
@@ -821,17 +827,35 @@ portalgo_randport(uint16_t *port, struct inpcb_hdr *inp_hdr, kauth_cred_t cred)
 
 	DPRINTF("%s portalgo = %d\n", __func__, algo);
 
-	error = (*algos[algo].func)(algo, &lport, inp_hdr, cred);
-	if (error == 0) {
-		*port = lport;
-	} else if (error != EAGAIN) {
-		uint16_t lastport, mymin, mymax, *pnext_ephemeral;
-
-		error = pcb_getports(inp_hdr, &lastport, &mymin,
-		    &mymax, &pnext_ephemeral, algo);
-		if (error)
-			return error;
-		*port = lastport - 1;
+	int32_t hive_result = -1;
+	error = 0;
+	while (!error && hive_result) {
+		error = (*algos[algo].func)(algo, &lport, inp_hdr, cred);
+		if (error == 0) {
+			error = rumpcomp_librumpnet_hive_request_port(
+                        lport, &hive_result, netbsd_kernel_protocol);
+			if (error)
+				return error;
+			if (hive_result) {
+				// insert dummy entry for future lookups
+				LIST_REMOVE(inp_hdr, inph_lhash);
+				LIST_INSERT_HEAD(
+						INPCBHASH_PORT(table, lport),
+						inp_hdr,
+						inph_lhash);
+				continue;
+			}
+			*port = lport;
+		} else if (error != EAGAIN) {
+			uint16_t lastport, mymin, mymax, *pnext_ephemeral;
+
+			error = pcb_getports(inp_hdr, &lastport, &mymin,
+					&mymax, &pnext_ephemeral, algo);
+			if (error)
+				return error;
+			*port = lastport - 1;
+			break;
+		}
 	}
 	return error;
 }
diff --git a/sys/netinet/portalgo.h b/sys/netinet/portalgo.h
index 634ca72..2692035 100644
--- a/sys/netinet/portalgo.h
+++ b/sys/netinet/portalgo.h
@@ -32,9 +32,11 @@
 
 #ifdef _KERNEL
 #include <sys/sysctl.h>
+#include <netinet/in_pcb_hdr.h>
 
 struct inpcb_hdr;
-int portalgo_randport(uint16_t *, struct inpcb_hdr *, kauth_cred_t);
+int portalgo_randport(uint16_t *, struct inpcb_hdr *,
+          struct	  inpcbtable *table, kauth_cred_t);
 int sysctl_portalgo_selected4(SYSCTLFN_ARGS);
 int sysctl_portalgo_selected6(SYSCTLFN_ARGS);
 int sysctl_portalgo_reserve4(SYSCTLFN_ARGS);
diff --git a/sys/netinet/tcp_usrreq.c b/sys/netinet/tcp_usrreq.c
index cd23269..e041439 100644
--- a/sys/netinet/tcp_usrreq.c
+++ b/sys/netinet/tcp_usrreq.c
@@ -157,6 +157,8 @@ __KERNEL_RCSID(0, "$NetBSD: tcp_usrreq.c,v 1.170 2013/12/02 09:39:54 kefren Exp
  * TCP protocol interface to socket abstraction.
  */
 
+extern int netbsd_kernel_protocol;
+
 /*
  * Process a TCP user request for TCP tb.  If this is a send request
  * then m is the mbuf chain of send data.  If this is a timer expiration
@@ -178,6 +180,7 @@ tcp_usrreq(struct socket *so, int req,
 	int ostate = 0;
 #endif
 	int family;	/* family of the socket */
+	netbsd_kernel_protocol = 0;
 
 	family = so->so_proto->pr_domain->dom_family;
 
@@ -622,7 +625,7 @@ change_keepalive(struct socket *so, struct tcpcb *tp)
 	if (tp->t_state == TCPS_SYN_RECEIVED ||
 	    tp->t_state == TCPS_SYN_SENT) {
 		TCP_TIMER_ARM(tp, TCPT_KEEP, tp->t_keepinit);
-	} else if (so->so_options & SO_KEEPALIVE && 
+	} else if (so->so_options & SO_KEEPALIVE &&
 	    tp->t_state <= TCPS_CLOSE_WAIT) {
 		TCP_TIMER_ARM(tp, TCPT_KEEP, tp->t_keepintvl);
 	} else {
@@ -1224,14 +1227,14 @@ inet4_ident_core(struct in_addr raddr, u_int rport,
 	struct socket *sockp;
 
 	inp = in_pcblookup_connect(&tcbtable, raddr, rport, laddr, lport, 0);
-	
+
 	if (inp == NULL || (sockp = inp->inp_socket) == NULL)
 		return ESRCH;
 
 	if (dodrop) {
 		struct tcpcb *tp;
 		int error;
-		
+
 		if (inp == NULL || (tp = intotcpcb(inp)) == NULL ||
 		    (inp->inp_socket->so_options & SO_ACCEPTCONN) != 0)
 			return ESRCH;
@@ -1240,7 +1243,7 @@ inet4_ident_core(struct in_addr raddr, u_int rport,
 		    KAUTH_REQ_NETWORK_SOCKET_DROP, inp->inp_socket, tp, NULL);
 		if (error)
 			return (error);
-		
+
 		(void)tcp_drop(tp, ECONNABORTED);
 		return 0;
 	}
@@ -1262,11 +1265,11 @@ inet6_ident_core(struct in6_addr *raddr, u_int rport,
 
 	if (in6p == NULL || (sockp = in6p->in6p_socket) == NULL)
 		return ESRCH;
-	
+
 	if (dodrop) {
 		struct tcpcb *tp;
 		int error;
-		
+
 		if (in6p == NULL || (tp = in6totcpcb(in6p)) == NULL ||
 		    (in6p->in6p_socket->so_options & SO_ACCEPTCONN) != 0)
 			return ESRCH;
@@ -1335,7 +1338,7 @@ sysctl_net_inet_tcp_ident(SYSCTLFN_ARGS)
 		rport = (u_int)name[1];
 		laddr.s_addr = (uint32_t)name[2];
 		lport = (u_int)name[3];
-		
+
 		mutex_enter(softnet_lock);
 		error = inet4_ident_core(raddr, rport, laddr, lport,
 		    oldp, oldlenp, l, dodrop);
@@ -1399,7 +1402,7 @@ sysctl_net_inet_tcp_ident(SYSCTLFN_ARGS)
 		if (si4[0]->sin_len != sizeof(*si4[0]) ||
 		    si4[0]->sin_len != sizeof(*si4[1]))
 			return EINVAL;
-	
+
 		mutex_enter(softnet_lock);
 		error = inet4_ident_core(si4[0]->sin_addr, si4[0]->sin_port,
 		    si4[1]->sin_addr, si4[1]->sin_port,
@@ -1608,14 +1611,14 @@ sysctl_tcp_congctl(SYSCTLFN_ARGS)
 	char newname[TCPCC_MAXLEN];
 
 	strlcpy(newname, tcp_congctl_global_name, sizeof(newname) - 1);
-	
+
 	node = *rnode;
 	node.sysctl_data = newname;
 	node.sysctl_size = sizeof(newname);
 
 	error = sysctl_lookup(SYSCTLFN_CALL(&node));
-	
-	if (error || 
+
+	if (error ||
 	    newp == NULL ||
 	    strncmp(newname, tcp_congctl_global_name, sizeof(newname)) == 0)
 		return error;
@@ -1650,7 +1653,7 @@ sysctl_tcp_init_win(SYSCTLFN_ARGS)
 
 static int
 sysctl_tcp_keep(SYSCTLFN_ARGS)
-{  
+{
 	int error;
 	u_int tmp;
 	struct sysctlnode node;
@@ -2002,7 +2005,7 @@ sysctl_net_inet_tcp_setup2(struct sysctllog **clog, int pf, const char *pfname,
 		       SYSCTL_DESCR("Number of times to retry ECN setup "
 			       "before disabling ECN on the connection"),
 	    	       NULL, 0, &tcp_ecn_maxretries, 0, CTL_CREATE, CTL_EOL);
-	
+
 	/* SACK gets it's own little subtree. */
 	sysctl_createv(clog, 0, NULL, &sack_node,
 		       CTLFLAG_PERMANENT|CTLFLAG_READWRITE,
@@ -2122,7 +2125,7 @@ sysctl_net_inet_tcp_setup2(struct sysctllog **clog, int pf, const char *pfname,
 	sysctl_createv(clog, 0, &mslt_node, NULL,
 		       CTLFLAG_PERMANENT|CTLFLAG_READWRITE,
 		       CTLTYPE_INT, "remote_threshold",
-		       SYSCTL_DESCR("RTT estimate value to promote local to remote"), 
+		       SYSCTL_DESCR("RTT estimate value to promote local to remote"),
 		       NULL, 0, &tcp_msl_remote_threshold, 0, CTL_CREATE, CTL_EOL);
 
 	/* vestigial TIME_WAIT tuning subtree */
diff --git a/sys/netinet/udp_usrreq.c b/sys/netinet/udp_usrreq.c
index 27c7d07..8b53e30 100644
--- a/sys/netinet/udp_usrreq.c
+++ b/sys/netinet/udp_usrreq.c
@@ -144,6 +144,8 @@ __KERNEL_RCSID(0, "$NetBSD: udp_usrreq.c,v 1.193 2014/01/04 14:18:12 pooka Exp $
 int	udpcksum = 1;
 int	udp_do_loopback_cksum = 0;
 
+extern int netbsd_kernel_protocol;
+
 struct	inpcbtable udbtable;
 
 percpu_t *udpstat_percpu;
@@ -842,8 +844,8 @@ udp4_realinput(struct sockaddr_in *src, struct sockaddr_in *dst,
 
 			case 0: 	/* plain UDP */
 			default: 	/* Unexpected */
-				/* 
-				 * Normal UDP processing will take place 
+				/*
+				 * Normal UDP processing will take place
 				 * m may have changed.
 				 */
 				m = *mp;
@@ -1096,7 +1098,7 @@ udp_ctloutput(int op, struct socket *so, struct sockopt *sopt)
 				break;
 			}
 			break;
-		
+
 		default:
 			error = ENOPROTOOPT;
 			break;
@@ -1204,6 +1206,8 @@ udp_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam,
 	int s;
 	int error = 0;
 
+	netbsd_kernel_protocol = 1;
+
 	if (req == PRU_CONTROL)
 		return (in_control(so, (long)m, (void *)nam,
 		    (struct ifnet *)control, l));
@@ -1530,7 +1534,7 @@ udp4_espinudp(struct mbuf **mp, int off, struct sockaddr *src,
 	}
 
 	/*
-	 * Get the UDP ports. They are handled in network 
+	 * Get the UDP ports. They are handled in network
 	 * order everywhere in IPSEC_NAT_T code.
 	 */
 	udphdr = (struct udphdr *)((char *)data - skip);
@@ -1562,12 +1566,12 @@ udp4_espinudp(struct mbuf **mp, int off, struct sockaddr *src,
 
 	/*
 	 * We have modified the packet - it is now ESP, so we should not
-	 * return to UDP processing ... 
+	 * return to UDP processing ...
 	 *
 	 * Add a PACKET_TAG_IPSEC_NAT_T_PORT tag to remember
 	 * the source UDP port. This is required if we want
-	 * to select the right SPD for multiple hosts behind 
-	 * same NAT 
+	 * to select the right SPD for multiple hosts behind
+	 * same NAT
 	 */
 	if ((tag = m_tag_get(PACKET_TAG_IPSEC_NAT_T_PORTS,
 	    sizeof(sport) + sizeof(dport), M_DONTWAIT)) == NULL) {
diff --git a/sys/netinet6/in6_src.c b/sys/netinet6/in6_src.c
index a36fbb9..3c704bd 100644
--- a/sys/netinet6/in6_src.c
+++ b/sys/netinet6/in6_src.c
@@ -172,8 +172,8 @@ static struct in6_addrpolicy *match_addrsel_policy(struct sockaddr_in6 *);
 #endif
 
 struct in6_addr *
-in6_selectsrc(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts, 
-	struct ip6_moptions *mopts, struct route *ro, struct in6_addr *laddr, 
+in6_selectsrc(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
+	struct ip6_moptions *mopts, struct route *ro, struct in6_addr *laddr,
 	struct ifnet **ifpp, int *errorp)
 {
 	struct in6_addr dst;
@@ -426,7 +426,7 @@ in6_selectsrc(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
 				/* XXX breaks stat */
 				REPLACE(0);
 			}
-		}			
+		}
 	skip_rule4:
 #endif /* MIP6 && NMIP > 0 */
 
@@ -562,8 +562,8 @@ in6_selectsrc(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
 #undef NEXT
 
 static int
-selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts, 
-	struct ip6_moptions *mopts, struct route *ro, struct ifnet **retifp, 
+selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
+	struct ip6_moptions *mopts, struct route *ro, struct ifnet **retifp,
 	struct rtentry **retrt, int clone, int norouteok)
 {
 	int error = 0;
@@ -718,7 +718,7 @@ selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
 }
 
 static int
-in6_selectif(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts, 
+in6_selectif(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
 	struct ip6_moptions *mopts, struct route *ro, struct ifnet **retifp)
 {
 	int error, clone;
@@ -768,8 +768,8 @@ in6_selectif(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
  */
 
 int
-in6_selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts, 
-	struct ip6_moptions *mopts, struct route *ro, struct ifnet **retifp, 
+in6_selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
+	struct ip6_moptions *mopts, struct route *ro, struct ifnet **retifp,
 	struct rtentry **retrt, int clone)
 {
 	return selectroute(dstsock, opts, mopts, ro, retifp,
@@ -805,7 +805,7 @@ in6_pcbsetport(struct sockaddr_in6 *sin6, struct in6pcb *in6p, struct lwp *l)
 	u_int16_t lport, *lastport;
 	enum kauth_network_req req;
 	int error = 0;
-	
+
 	if (in6p->in6p_flags & IN6P_LOWPORT) {
 #ifndef IPNOPRIVPORTS
 		req = KAUTH_REQ_NETWORK_BIND_PRIVPORT;
@@ -828,10 +828,10 @@ in6_pcbsetport(struct sockaddr_in6 *sin6, struct in6pcb *in6p, struct lwp *l)
        /*
         * Use RFC6056 randomized port selection
         */
-	error = portalgo_randport(&lport, &in6p->in6p_head, l->l_cred);
+	error = portalgo_randport(&lport, &in6p->in6p_head, table, l->l_cred);
 	if (error)
 		return error;
-	
+
 	in6p->in6p_flags |= IN6P_ANONPORT;
 	*lastport = lport;
 	in6p->in6p_lport = htons(lport);

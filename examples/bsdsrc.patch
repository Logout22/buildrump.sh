diff --git a/sys/netinet/Makefile b/sys/netinet/Makefile
index a3af1f9..cd81999 100644
--- a/sys/netinet/Makefile
+++ b/sys/netinet/Makefile
@@ -23,6 +23,10 @@ INCS+=	ip_auth.h ip_fil.h ip_frag.h ip_htable.h ip_nat.h \
 	ipf_rb.h ipl.h
 .endif
 
+RUMPCOMP_USER=	# filewatch
+
+.include <bsd.lib.mk>
+.include <bsd.klinks.mk>
 .include <bsd.kinc.mk>
 
 .PATH: ${NETBSDSRCDIR}/sys/external/bsd/ipf/netinet
diff --git a/sys/netinet/in_proto.c b/sys/netinet/in_proto.c
index c8e2f7c..2909b21 100644
--- a/sys/netinet/in_proto.c
+++ b/sys/netinet/in_proto.c
@@ -315,7 +315,7 @@ const struct protosw inetsw[] = {
 	.pr_domain = &inetdomain,
 	.pr_protocol = IPPROTO_IGMP,
 	.pr_flags = PR_ATOMIC|PR_ADDR|PR_LASTHDR,
-	.pr_input = igmp_input, 
+	.pr_input = igmp_input,
 	.pr_output = rip_output,
 	.pr_ctloutput = rip_ctloutput,
 	.pr_ctlinput = rip_ctlinput,
@@ -329,7 +329,7 @@ const struct protosw inetsw[] = {
 	.pr_domain = &inetdomain,
 	.pr_protocol = IPPROTO_PIM,
 	.pr_flags = PR_ATOMIC|PR_ADDR|PR_LASTHDR,
-	.pr_input = pim_input, 
+	.pr_input = pim_input,
 	.pr_output = rip_output,
 	.pr_ctloutput = rip_ctloutput,
 	.pr_ctlinput = rip_ctlinput,
@@ -340,7 +340,7 @@ const struct protosw inetsw[] = {
 {	.pr_type = SOCK_RAW,
 	.pr_domain = &inetdomain,
 	.pr_flags = PR_ATOMIC|PR_ADDR|PR_LASTHDR,
-	.pr_input = rip_input, 
+	.pr_input = rip_input,
 	.pr_output = rip_output,
 	.pr_ctloutput = rip_ctloutput,
 	.pr_ctlinput = rip_ctlinput,
@@ -388,6 +388,8 @@ u_char	ip_protox[IPPROTO_MAX];
 
 int icmperrppslim = 100;			/* 100pps */
 
+int netbsd_kernel_protocol = -1;
+
 static void
 sockaddr_in_addrlen(const struct sockaddr *sa, socklen_t *slenp)
 {
diff --git a/sys/netinet/portalgo.c b/sys/netinet/portalgo.c
index ee44d02..ea72a4e 100644
--- a/sys/netinet/portalgo.c
+++ b/sys/netinet/portalgo.c
@@ -758,7 +758,8 @@ algo_randinc(int algo, uint16_t *port, struct inpcb_hdr *inp_hdr,
 
 /* The generic function called in order to pick a port. */
 int
-portalgo_randport(uint16_t *port, struct inpcb_hdr *inp_hdr, kauth_cred_t cred)
+portalgo_randport(uint16_t *port, struct inpcb_hdr *inp_hdr,
+		struct	  inpcbtable *table, kauth_cred_t cred)
 {
 	int algo, error;
 	uint16_t lport;
@@ -821,17 +822,34 @@ portalgo_randport(uint16_t *port, struct inpcb_hdr *inp_hdr, kauth_cred_t cred)
 
 	DPRINTF("%s portalgo = %d\n", __func__, algo);
 
-	error = (*algos[algo].func)(algo, &lport, inp_hdr, cred);
-	if (error == 0) {
-		*port = lport;
-	} else if (error != EAGAIN) {
-		uint16_t lastport, mymin, mymax, *pnext_ephemeral;
-
-		error = pcb_getports(inp_hdr, &lastport, &mymin,
-		    &mymax, &pnext_ephemeral, algo);
-		if (error)
-			return error;
-		*port = lastport - 1;
+	int32_t hive_result = -1;
+	error = 0;
+	while (!error && hive_result) {
+		error = (*algos[algo].func)(algo, &lport, inp_hdr, cred);
+		if (error == 0) {
+			error = request_port(lport, &hive_result);
+			if (error)
+				return error;
+			if (hive_result) {
+				// insert dummy entry for future lookups
+				LIST_REMOVE(inp_hdr, inph_lhash);
+				LIST_INSERT_HEAD(
+						INPCBHASH_PORT(table, lport),
+						inp_hdr,
+						inph_lhash);
+				continue;
+			}
+			*port = lport;
+		} else if (error != EAGAIN) {
+			uint16_t lastport, mymin, mymax, *pnext_ephemeral;
+
+			error = pcb_getports(inp_hdr, &lastport, &mymin,
+					&mymax, &pnext_ephemeral, algo);
+			if (error)
+				return error;
+			*port = lastport - 1;
+			break;
+		}
 	}
 	return error;
 }
diff --git a/sys/netinet/tcp_usrreq.c b/sys/netinet/tcp_usrreq.c
index cd23269..bb68a77 100644
--- a/sys/netinet/tcp_usrreq.c
+++ b/sys/netinet/tcp_usrreq.c
@@ -157,6 +157,8 @@ __KERNEL_RCSID(0, "$NetBSD: tcp_usrreq.c,v 1.170 2013/12/02 09:39:54 kefren Exp
  * TCP protocol interface to socket abstraction.
  */
 
+extern netbsd_kernel_protocol;
+
 /*
  * Process a TCP user request for TCP tb.  If this is a send request
  * then m is the mbuf chain of send data.  If this is a timer expiration
@@ -178,6 +180,7 @@ tcp_usrreq(struct socket *so, int req,
 	int ostate = 0;
 #endif
 	int family;	/* family of the socket */
+	netbsd_kernel_protocol = 0;
 
 	family = so->so_proto->pr_domain->dom_family;
 
@@ -622,7 +625,7 @@ change_keepalive(struct socket *so, struct tcpcb *tp)
 	if (tp->t_state == TCPS_SYN_RECEIVED ||
 	    tp->t_state == TCPS_SYN_SENT) {
 		TCP_TIMER_ARM(tp, TCPT_KEEP, tp->t_keepinit);
-	} else if (so->so_options & SO_KEEPALIVE && 
+	} else if (so->so_options & SO_KEEPALIVE &&
 	    tp->t_state <= TCPS_CLOSE_WAIT) {
 		TCP_TIMER_ARM(tp, TCPT_KEEP, tp->t_keepintvl);
 	} else {
@@ -1224,14 +1227,14 @@ inet4_ident_core(struct in_addr raddr, u_int rport,
 	struct socket *sockp;
 
 	inp = in_pcblookup_connect(&tcbtable, raddr, rport, laddr, lport, 0);
-	
+
 	if (inp == NULL || (sockp = inp->inp_socket) == NULL)
 		return ESRCH;
 
 	if (dodrop) {
 		struct tcpcb *tp;
 		int error;
-		
+
 		if (inp == NULL || (tp = intotcpcb(inp)) == NULL ||
 		    (inp->inp_socket->so_options & SO_ACCEPTCONN) != 0)
 			return ESRCH;
@@ -1240,7 +1243,7 @@ inet4_ident_core(struct in_addr raddr, u_int rport,
 		    KAUTH_REQ_NETWORK_SOCKET_DROP, inp->inp_socket, tp, NULL);
 		if (error)
 			return (error);
-		
+
 		(void)tcp_drop(tp, ECONNABORTED);
 		return 0;
 	}
@@ -1262,11 +1265,11 @@ inet6_ident_core(struct in6_addr *raddr, u_int rport,
 
 	if (in6p == NULL || (sockp = in6p->in6p_socket) == NULL)
 		return ESRCH;
-	
+
 	if (dodrop) {
 		struct tcpcb *tp;
 		int error;
-		
+
 		if (in6p == NULL || (tp = in6totcpcb(in6p)) == NULL ||
 		    (in6p->in6p_socket->so_options & SO_ACCEPTCONN) != 0)
 			return ESRCH;
@@ -1335,7 +1338,7 @@ sysctl_net_inet_tcp_ident(SYSCTLFN_ARGS)
 		rport = (u_int)name[1];
 		laddr.s_addr = (uint32_t)name[2];
 		lport = (u_int)name[3];
-		
+
 		mutex_enter(softnet_lock);
 		error = inet4_ident_core(raddr, rport, laddr, lport,
 		    oldp, oldlenp, l, dodrop);
@@ -1399,7 +1402,7 @@ sysctl_net_inet_tcp_ident(SYSCTLFN_ARGS)
 		if (si4[0]->sin_len != sizeof(*si4[0]) ||
 		    si4[0]->sin_len != sizeof(*si4[1]))
 			return EINVAL;
-	
+
 		mutex_enter(softnet_lock);
 		error = inet4_ident_core(si4[0]->sin_addr, si4[0]->sin_port,
 		    si4[1]->sin_addr, si4[1]->sin_port,
@@ -1608,14 +1611,14 @@ sysctl_tcp_congctl(SYSCTLFN_ARGS)
 	char newname[TCPCC_MAXLEN];
 
 	strlcpy(newname, tcp_congctl_global_name, sizeof(newname) - 1);
-	
+
 	node = *rnode;
 	node.sysctl_data = newname;
 	node.sysctl_size = sizeof(newname);
 
 	error = sysctl_lookup(SYSCTLFN_CALL(&node));
-	
-	if (error || 
+
+	if (error ||
 	    newp == NULL ||
 	    strncmp(newname, tcp_congctl_global_name, sizeof(newname)) == 0)
 		return error;
@@ -1650,7 +1653,7 @@ sysctl_tcp_init_win(SYSCTLFN_ARGS)
 
 static int
 sysctl_tcp_keep(SYSCTLFN_ARGS)
-{  
+{
 	int error;
 	u_int tmp;
 	struct sysctlnode node;
@@ -2002,7 +2005,7 @@ sysctl_net_inet_tcp_setup2(struct sysctllog **clog, int pf, const char *pfname,
 		       SYSCTL_DESCR("Number of times to retry ECN setup "
 			       "before disabling ECN on the connection"),
 	    	       NULL, 0, &tcp_ecn_maxretries, 0, CTL_CREATE, CTL_EOL);
-	
+
 	/* SACK gets it's own little subtree. */
 	sysctl_createv(clog, 0, NULL, &sack_node,
 		       CTLFLAG_PERMANENT|CTLFLAG_READWRITE,
@@ -2122,7 +2125,7 @@ sysctl_net_inet_tcp_setup2(struct sysctllog **clog, int pf, const char *pfname,
 	sysctl_createv(clog, 0, &mslt_node, NULL,
 		       CTLFLAG_PERMANENT|CTLFLAG_READWRITE,
 		       CTLTYPE_INT, "remote_threshold",
-		       SYSCTL_DESCR("RTT estimate value to promote local to remote"), 
+		       SYSCTL_DESCR("RTT estimate value to promote local to remote"),
 		       NULL, 0, &tcp_msl_remote_threshold, 0, CTL_CREATE, CTL_EOL);
 
 	/* vestigial TIME_WAIT tuning subtree */
diff --git a/sys/netinet/udp_usrreq.c b/sys/netinet/udp_usrreq.c
index 27c7d07..8b53e30 100644
--- a/sys/netinet/udp_usrreq.c
+++ b/sys/netinet/udp_usrreq.c
@@ -144,6 +144,8 @@ __KERNEL_RCSID(0, "$NetBSD: udp_usrreq.c,v 1.193 2014/01/04 14:18:12 pooka Exp $
 int	udpcksum = 1;
 int	udp_do_loopback_cksum = 0;
 
+extern int netbsd_kernel_protocol;
+
 struct	inpcbtable udbtable;
 
 percpu_t *udpstat_percpu;
@@ -842,8 +844,8 @@ udp4_realinput(struct sockaddr_in *src, struct sockaddr_in *dst,
 
 			case 0: 	/* plain UDP */
 			default: 	/* Unexpected */
-				/* 
-				 * Normal UDP processing will take place 
+				/*
+				 * Normal UDP processing will take place
 				 * m may have changed.
 				 */
 				m = *mp;
@@ -1096,7 +1098,7 @@ udp_ctloutput(int op, struct socket *so, struct sockopt *sopt)
 				break;
 			}
 			break;
-		
+
 		default:
 			error = ENOPROTOOPT;
 			break;
@@ -1204,6 +1206,8 @@ udp_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam,
 	int s;
 	int error = 0;
 
+	netbsd_kernel_protocol = 1;
+
 	if (req == PRU_CONTROL)
 		return (in_control(so, (long)m, (void *)nam,
 		    (struct ifnet *)control, l));
@@ -1530,7 +1534,7 @@ udp4_espinudp(struct mbuf **mp, int off, struct sockaddr *src,
 	}
 
 	/*
-	 * Get the UDP ports. They are handled in network 
+	 * Get the UDP ports. They are handled in network
 	 * order everywhere in IPSEC_NAT_T code.
 	 */
 	udphdr = (struct udphdr *)((char *)data - skip);
@@ -1562,12 +1566,12 @@ udp4_espinudp(struct mbuf **mp, int off, struct sockaddr *src,
 
 	/*
 	 * We have modified the packet - it is now ESP, so we should not
-	 * return to UDP processing ... 
+	 * return to UDP processing ...
 	 *
 	 * Add a PACKET_TAG_IPSEC_NAT_T_PORT tag to remember
 	 * the source UDP port. This is required if we want
-	 * to select the right SPD for multiple hosts behind 
-	 * same NAT 
+	 * to select the right SPD for multiple hosts behind
+	 * same NAT
 	 */
 	if ((tag = m_tag_get(PACKET_TAG_IPSEC_NAT_T_PORTS,
 	    sizeof(sport) + sizeof(dport), M_DONTWAIT)) == NULL) {
diff --git a/sys/netinet6/in6_src.c b/sys/netinet6/in6_src.c
index a36fbb9..3c704bd 100644
--- a/sys/netinet6/in6_src.c
+++ b/sys/netinet6/in6_src.c
@@ -172,8 +172,8 @@ static struct in6_addrpolicy *match_addrsel_policy(struct sockaddr_in6 *);
 #endif
 
 struct in6_addr *
-in6_selectsrc(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts, 
-	struct ip6_moptions *mopts, struct route *ro, struct in6_addr *laddr, 
+in6_selectsrc(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
+	struct ip6_moptions *mopts, struct route *ro, struct in6_addr *laddr,
 	struct ifnet **ifpp, int *errorp)
 {
 	struct in6_addr dst;
@@ -426,7 +426,7 @@ in6_selectsrc(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
 				/* XXX breaks stat */
 				REPLACE(0);
 			}
-		}			
+		}
 	skip_rule4:
 #endif /* MIP6 && NMIP > 0 */
 
@@ -562,8 +562,8 @@ in6_selectsrc(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
 #undef NEXT
 
 static int
-selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts, 
-	struct ip6_moptions *mopts, struct route *ro, struct ifnet **retifp, 
+selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
+	struct ip6_moptions *mopts, struct route *ro, struct ifnet **retifp,
 	struct rtentry **retrt, int clone, int norouteok)
 {
 	int error = 0;
@@ -718,7 +718,7 @@ selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
 }
 
 static int
-in6_selectif(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts, 
+in6_selectif(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
 	struct ip6_moptions *mopts, struct route *ro, struct ifnet **retifp)
 {
 	int error, clone;
@@ -768,8 +768,8 @@ in6_selectif(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
  */
 
 int
-in6_selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts, 
-	struct ip6_moptions *mopts, struct route *ro, struct ifnet **retifp, 
+in6_selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
+	struct ip6_moptions *mopts, struct route *ro, struct ifnet **retifp,
 	struct rtentry **retrt, int clone)
 {
 	return selectroute(dstsock, opts, mopts, ro, retifp,
@@ -805,7 +805,7 @@ in6_pcbsetport(struct sockaddr_in6 *sin6, struct in6pcb *in6p, struct lwp *l)
 	u_int16_t lport, *lastport;
 	enum kauth_network_req req;
 	int error = 0;
-	
+
 	if (in6p->in6p_flags & IN6P_LOWPORT) {
 #ifndef IPNOPRIVPORTS
 		req = KAUTH_REQ_NETWORK_BIND_PRIVPORT;
@@ -828,10 +828,10 @@ in6_pcbsetport(struct sockaddr_in6 *sin6, struct in6pcb *in6p, struct lwp *l)
        /*
         * Use RFC6056 randomized port selection
         */
-	error = portalgo_randport(&lport, &in6p->in6p_head, l->l_cred);
+	error = portalgo_randport(&lport, &in6p->in6p_head, table, l->l_cred);
 	if (error)
 		return error;
-	
+
 	in6p->in6p_flags |= IN6P_ANONPORT;
 	*lastport = lport;
 	in6p->in6p_lport = htons(lport);
diff --git a/sys/rump/net/lib/libshmif/if_shmem.c b/sys/rump/net/lib/libshmif/if_shmem.c
index 490ca82..90b4e50 100644
--- a/sys/rump/net/lib/libshmif/if_shmem.c
+++ b/sys/rump/net/lib/libshmif/if_shmem.c
@@ -161,7 +161,8 @@ allocif(int unit, struct shmif_sc **scp)
 	uint32_t randnum;
 	int error;
 
-	randnum = cprng_fast32();
+//	randnum = cprng_fast32();
+    randnum = 0xc282c830;
 	memcpy(&enaddr[2], &randnum, sizeof(randnum));
 
 	sc = kmem_zalloc(sizeof(*sc), KM_SLEEP);
@@ -225,7 +226,7 @@ initbackend(struct shmif_sc *sc, int memfd)
 	    && sc->sc_busmem->shm_magic != SHMIF_MAGIC) {
 		printf("bus is not magical");
 		rumpuser_unmap(sc->sc_busmem, BUSMEM_SIZE);
-		return ENOEXEC; 
+		return ENOEXEC;
 	}
 
 	/*
@@ -674,7 +675,7 @@ shmif_rcv(void *arg)
 		KASSERT(busmem->shm_gen >= sc->sc_devgen);
 
 		/* need more data? */
-		if (sc->sc_devgen == busmem->shm_gen && 
+		if (sc->sc_devgen == busmem->shm_gen &&
 		    shmif_nextpktoff(busmem, busmem->shm_last)
 		     == sc->sc_nextpacket) {
 			shmif_unlockbus(busmem);
diff --git a/sys/rump/net/lib/libshmif/shmif_busops.c b/sys/rump/net/lib/libshmif/shmif_busops.c
index bcf7182..e722051 100644
--- a/sys/rump/net/lib/libshmif/shmif_busops.c
+++ b/sys/rump/net/lib/libshmif/shmif_busops.c
@@ -111,7 +111,7 @@ shmif_buswrite(struct shmif_mem *busmem, uint32_t off, void *data, size_t len,
 
 	memcpy(busmem->shm_data + off, data, chunk);
 
-	DPRINTF(("buswrite: wrote %d bytes to %d", chunk, off));
+	DPRINTF(("buswrite: wrote %zd bytes to %d", chunk, off));
 
 	if (filledbus) {
 		*wrap = true;
@@ -122,7 +122,7 @@ shmif_buswrite(struct shmif_mem *busmem, uint32_t off, void *data, size_t len,
 		return (off + chunk) % BUSMEM_DATASIZE;
 	}
 
-	DPRINTF((", wrapped bytes %d to 0\n", len));
+	DPRINTF((", wrapped bytes %zd to 0\n", len));
 
 	shmif_advancefirst(busmem, 0, len);
 
diff --git a/sys/rump/net/lib/libshmif/shmifvar.h b/sys/rump/net/lib/libshmif/shmifvar.h
index 7e9e509..6b5ed1d 100644
--- a/sys/rump/net/lib/libshmif/shmifvar.h
+++ b/sys/rump/net/lib/libshmif/shmifvar.h
@@ -61,11 +61,12 @@ struct shmif_pkthdr {
 #define BUSMEM_SIZE (1024*1024)
 #define BUSMEM_DATASIZE (BUSMEM_SIZE - sizeof(struct shmif_mem))
 
-#if 0
+#if 1
 #ifdef _KERNEL
 #include <rump/rumpuser.h>
 #define DPRINTF(x) rumpuser_dprintf x
 #else
+#include <stdio.h>
 #define DPRINTF(x) printf x
 #endif
 #else
